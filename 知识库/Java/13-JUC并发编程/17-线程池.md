# 线程池

线程池: 三大方法,七大参数,四种拒绝策略

当程序允许时需要的链接如:JDBC链接，IO链接等等他们开启或关闭会极大的耗费资源,这时则引入了一个池化技术的概念。
池化技术本质:事先准备好一些资源,要用的时候来这里取,用完了在放回去,这样就不用一直开启关闭浪费资源了.

线程池的好处:

- 降低资源消耗
- 效率大大提升
- 方便我们管理

线程复用可以控制最大并发数,管理线程！

### 线程池 - 三大方法

```java
package com.zhengqing.demo.daily.juc;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TestExecutor {

    public static void main(String[] args) {
//        ExecutorService executorService = Executors.newSingleThreadExecutor();//单个线程
//        ExecutorService executorService = Executors.newFixedThreadPool(100);//固定线程池大小
        ExecutorService executorService = Executors.newCachedThreadPool();//可伸缩的线程池
        try {
            for (int i = 0; i < 100; i++) {
                executorService.execute(() -> {
                    System.out.println("当前线程： " + Thread.currentThread().getName());
                });
            }
        } finally {
            //线程池用完一定要关闭
            executorService.shutdown();
        }
    }

}
```

### 线程池 - 七大参数

```
//单个线程    
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

//固定线程池大写
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

//可伸缩的线程池
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE, //这里最大核心线程约为21亿!
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

//本质开启线程池调用了ThreadPoolExecutor()
public ThreadPoolExecutor(int corePoolSize, //核心线程池大小
                          int maximumPoolSize,    //最大核心线程池大小
                          long keepAliveTime,     //超时了没有人调用就会释放
                          TimeUnit unit,          //超时单位
                          BlockingQueue<Runnable> workQueue, //阻塞队列
                          ThreadFactory threadFactory,       //线程工厂，创建线程的，一般不动用
                          RejectedExecutionHandler handler) { //拒绝策略
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

### 手动创建线程池

```java
package com.zhengqing.demo.daily.juc;

import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TestThreadPoolExecutor {
    public static void main(String[] args) {
        /**
         * 四种拒绝策略:
         * 1. new ThreadPoolExecutor.AbortPolicy() // 线程满了还有线程要进入则,不做处理,直接抛出异常
         * 2. new ThreadPoolExecutor.CallerRunsPolicy() // 那来的那里去
         * 3. new ThreadPoolExecutor.DiscardPolicy() // 队列满了丢掉任务,直接开摆,不会抛出异常
         * 4. new ThreadPoolExecutor.DiscardOldestPolicy() // 队列满了,尝试去和最早的竞争，不会抛出异常
         */
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,
                5,
                2,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i < 19; i++) {
            executor.execute(() -> {
                System.out.println(Thread.currentThread().getName() + "线程");
            });
        }
    }
}
```

### 池的最大的线程如何去设置?

了解：IO密集型与CPU密集型

- CPU密集型：服务器主要运行计算密集型的应用程序，如图像和视频处理、3d建模和渲染等。在此情况下，服务器需要更多的cpu资源才能处理大量的计算任务。
- IO密集型： 频繁访问存储系统或网络通信的应用程序。eg: 数据库服务器、文件服务器以及web服务器等。这些应用程序需要服务器快速地读取和写入大量数据，并及时响应客户端请求。

有时候，一个服务器既可能是cpu密集型，也可能是io密集型。为了进一步确定服务器的类型，可以使用系统监视器工具观察其资源使用情况。例如，如果cpu使用率高，而硬盘io使用率相对较低，则这个服务器可能是cpu密集型。反之，如果硬盘io使用率高，而cpu使用率相对较低，则可能是io密集型。

> java中可以使用`Runtime.getRuntime().availableProcessors()`方法检测出电脑是几核的


