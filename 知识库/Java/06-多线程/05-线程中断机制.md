# 线程中断机制

Java线程有多种方法可以中断停止，具体取决于线程需要的控制和资源。下面是一些常见的方式

### 1、使用标志位

为了能够正常地停止一个线程，你可以在代码中定义一个布尔类型的标志位，然后在线程运行时侦测这个标志位是否已被设置为true，如果是，线程就执行结束操作。

```java
public class MyThread extends Thread {

    private volatile boolean stop;

    public void setStop(boolean stop) {
        this.stop = stop;
    }

    @Override
    public void run() {
        while (!stop) {
            // do something
        }
        // perform clean-up work here
    }
}
```

### 2、使用 interrupt()

interrupt() 方法用于中断线程。当对一个线程调用 interrupt() 方法时，它会将该线程的中断状态设置为 "中断"。
这个状态可通过 isInterrupted() 方法进行查询。

一般来说，一个线程被中断意味着应该停止当前的执行，并尽快退出线程。
但是，interrupt() 方法并不能直接终止线程的执行。
它只是向目标线程发出一个中断信号，目标线程可以根据自身的逻辑决定如何处理中断状态。
在某些情况下，线程可以忽略中断请求并继续执行。
在其他情况下，线程可以通过检查中断状态并做出相应的响应来进行优雅地退出。

```
public class MyThread extends Thread {
    public void run() {
        while (!isInterrupted()) {
            // 线程逻辑...
        }
    }
}

// 中断线程
MyThread thread = new MyThread();
thread.start();
thread.interrupt();
```

在上面的示例中，run() 方法中使用了 isInterrupted() 来检查线程是否被中断，然后决定是否继续执行。
当主线程调用 interrupt() 方法后，isInterrupted() 会返回 true，使得线程能够安全地退出循环并结束执行。

需要注意的是，在捕获 InterruptedException 的方法（如 sleep()、wait() 等）中使用 interrupt() 方法，
会产生一个 InterruptedException 异常。这个异常可以用来中断阻塞操作并优雅地退出线程。

总之，interrupt() 方法只是发送一个中断信号，并不直接终止线程的执行。具体的中断处理逻辑需要由线程自身来决定。

### 3、使用 stop()

虽然这个方法能够立即终止一个线程，但并不推荐使用它，因为它可能导致一些非预期的结果。

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        while (true) {
            // do something
        }
        // perform clean-up work here
    }
}

//MyThread myThread = new MyThread();
//myThread.start();
//myThread.stop(); // 立即停止 MyThread 线程
```

### 4、使用 Future

使用 `Future` 和 `ExecutorService` 来停止运行中的Java线程。
需要注意的是，在使用 `cancel()` 方法来取消任务时，实际上只是给线程发送一个中断信号，而不是直接停止线程。
因此，需要在任务代码中检查中断状态并根据需要提前结束线程才能确保任务可靠地结束。

```java
import java.util.concurrent.*;

public class StopThreadExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Callable<Void> task = new Callable<Void>() {
            public Void call() throws Exception {
                while (true) {
                    // 这里是线程要执行的代码
                }
            }
        };
        Future<Void> future = executor.submit(task);
        Thread.sleep(1000); //等待线程执行一段时间
        future.cancel(true); // 取消任务
        executor.shutdown(); // 关闭线程池，释放资源
    }
}
```
