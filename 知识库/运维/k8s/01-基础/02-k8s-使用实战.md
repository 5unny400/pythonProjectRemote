@[TOC](文章目录)

### 一、前言

1. [运维(5) Windows10专业版安装K8s](https://zhengqing.blog.csdn.net/article/details/113468954)
2. [运维(29) CentOS7.6通过KubeOperator部署Kubernetes集群](https://zhengqing.blog.csdn.net/article/details/124060648)
3. [运维(33) CentOS7.6通过Kubeadm部署Kubernetes集群](https://zhengqing.blog.csdn.net/article/details/124306694)

> 可参考 [https://www.yuque.com/leifengyang/oncloud/ctiwgo](https://www.yuque.com/leifengyang/oncloud/ctiwgo)

### 二、资源创建

#### 1、命令行

```shell
# ex:
# kubectl create ns hello
```

#### 2、配置文件

```shell
# ex:
# kubectl apply -f xxx.yaml
```

#### 3、可视化界面

![在这里插入图片描述](https://img-blog.csdnimg.cn/1b66ab1a652e4f7c8ae4b9840a271032.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

### 三、命名空间

> 隔离资源

#### 1、命令行

```shell
# 查看命名空间
kubectl get ns

# 查看默认命名空间`default`下的应用 -- 如果操作不指定命名空间，默认都是放在`default`命名空间下
kubectl get pods
# 查看所有命名空间下的应用
kubectl get pods -A
# 查看指定命名空间`xxx`下的应用
kubectl get pods -n xxx

# 创建命名空间 `zhengqingya`
kubectl create ns zhengqingya
# 删除 -- 会将其下所有应用删除
kubectl delete ns zhengqingya
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/ee3d276bc8a240928698c93af5fd4996.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 2、配置文件

```shell
cat <<EOF | sudo tee ./zhengqingya.yaml

apiVersion: v1
kind: Namespace
metadata:
  name: zhengqingya
  
EOF


# 创建资源
kubectl apply -f zhengqingya.yaml
# 删除
kubectl delete -f zhengqingya.yaml
```

### 四、Pod

> 运行中的一组容器，Pod是kubernetes中应用的最小单位。

#### 1、命令行

```shell
# 创建一个叫 `mynginx` 的 `nginx` 容器
kubectl run mynginx --image=nginx

# 查看`default`空间的Pod
kubectl get pod

# 如果应用未运行，可查看描述信息，看看应用执行相关事件处理
# kubectl describe pod Pod名
kubectl describe pod mynginx

# 删除
kubectl delete pod mynginx

# 查看运行日志
kubectl logs -f mynginx

# 输出更完善的信息 -- 每个Pod，k8s都会分配一个ip   集群中的任意机器都能访问
kubectl get pod -owide

# 查看
curl 10.0.169.136:80

# 进入容器
kubectl exec -it mynginx -- /bin/bash
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5e12cc2ec5de46d793b57b28da31dc75.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 2、配置文件

```shell
cat <<EOF | sudo tee ./mynginx.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: mynginx
  name: mynginx
  namespace: default
spec:
  containers:
  - image: nginx
    name: mynginx
  
EOF


# 创建
kubectl apply -f mynginx.yaml
# 删除
kubectl delete -f mynginx.yaml
```

一个Pod部署多个容器

> tips: 无法部署多个相同容器，会出现端口占用问题！

```shell
cat <<EOF | sudo tee ./my-pods.yaml

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: my-pods
  name: my-pods
spec:
  containers:
  - image: nginx
    name: nginx
  - image: tomcat
    name: tomcat
    
EOF


# 创建
kubectl apply -f my-pods.yaml
# 删除
kubectl delete -f my-pods.yaml


# 每隔1秒运行 查看数据
watch -n 1 kubectl get pod
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/131402f856cf4288beedf353bcaf7d76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 3、`Kubernetes Dashboard`可视化界面中操作

切换到指定命名空间下 -> `＋` -> `输入并创建`
![在这里插入图片描述](https://img-blog.csdnimg.cn/eff2b440f0af4474bf2b0f1dfd57e5e4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/a06f0694f56e49c399f53915e250913d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

查看日志
![在这里插入图片描述](https://img-blog.csdnimg.cn/bd5286722a9f4bf29b81194e2ab2e2f6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f9807de751f34ae28957e4648d99bb6c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

### 五、Deployment

> 控制Pod，使Pod拥有多副本，自愈，扩缩容等能力

```shell
kubectl create deployment my-dep-nginx --image=nginx


# 新开一个窗口：每隔1秒运行 查看数据
watch -n 1 kubectl get pod


# 删除应用
kubectl delete pod my-dep-nginx-xxx

# 然后在新开的窗口查看应用会自己在删除后 再次启动   =>   自愈能力
# 下面方式创建的应用删除后不会自自启动
kubectl run mynginx --image=nginx
kubectl delete pod mynginx


# 查看部署
kubectl get deploy
# 删除部署`my-dep-nginx`
kubectl delete deploy my-dep-nginx
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/32413509815d4d9f990f9f7fdf870d56.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 1、多副本

##### a、命令行

```shell
# 启动3份副本，会在工作机器中随机部署      ex: 机器1部署2份  机器2部署1份  如果其中一个应用蹦了，会再随机启动一个，保证存在3个副本
kubectl create deployment my-dep-nginx --image=nginx --replicas=3
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/56a81f23694944a8a6538aaaf3e2e3c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### b、配置文件

```shell
# 删除命令行部署的`my-dep-nginx`
kubectl delete deploy my-dep-nginx


cat <<EOF | sudo tee ./my-dep-nginx.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: my-dep-nginx
  name: my-dep-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-dep-nginx
  template:
    metadata:
      labels:
        app: my-dep-nginx
    spec:
      containers:
      - image: nginx
        name: nginx
        
EOF


# 创建
kubectl apply -f my-dep-nginx.yaml
# 删除
kubectl delete -f my-dep-nginx.yaml
```

##### c、`Kubernetes Dashboard`可视化界面中操作

切换到指定命名空间下 -> `＋` -> `从表单创建`
![在这里插入图片描述](https://img-blog.csdnimg.cn/de6affa342fd4decb3f4b38123667f81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 2、扩缩容

##### 方式1

```shell
# 将之前部署的3份 扩展到 5份
kubectl scale deploy/my-dep-nginx --replicas=5
# 缩容
kubectl scale deploy/my-dep-nginx --replicas=2

# 查看
kubectl get pod
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/4e22c0808b684304a731497fc5fbcc01.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 方式2

```shell
# 修改 `replicas` 值 即可
kubectl edit deploy my-dep-nginx

# 查看
kubectl get pod
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/72d4dc3b45354132961ee64cd61525a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 方式3

`Kubernetes Dashboard`可视化界面中操作
![在这里插入图片描述](https://img-blog.csdnimg.cn/5e73495f84fe4532aea56e22552be9c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/66153a93ea164ebbbff0e9df6a12e579.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 3、自愈&故障转移

以下情况

1. 停止容器
2. 删除Pod
3. 容器崩溃
4. 宕机
5. ...

其下的应用会再自启动一份到集群下任意工作机器 => 自愈&故障转移

```shell
# 模拟：在工作机器上停掉应用
docker stop xxx

# 监控 -- 展示应用的状态变化过程
kubectl get pod -w
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5bfcffa2098a41c5b67af80d2b02e8f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 4、滚动更新

> 上次部署版本v1；这次部署版本v2，会先启动v2版本的新应用，等新应用启动成功之后，再杀死旧应用v1。

```shell
kubectl create deployment my-dep-nginx --image=nginx --replicas=2

# 部署新版本
kubectl set image deploy/my-dep-nginx nginx=nginx:1.21.6 --record

# 查看变更进度
kubectl rollout status deploy/my-dep-nginx
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ba1430984dd4defabd403d26d71ee9f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 5、版本回退

> v2版本回退到v1版本

```shell
# 历史记录
kubectl rollout history deployment/my-dep-nginx
# 查看某个历史详情
kubectl rollout history deployment/my-dep-nginx --revision=2

# 回滚 -- 上次
kubectl rollout undo deploy/my-dep-nginx
# 回滚 -- 指定版本
kubectl rollout undo deploy/my-dep-nginx --to-revision=1

# 监控 -- 展示应用的状态变化过程
kubectl get pod -w

# 查看是否回退到之前版本 -- 看image镜像版本确认
kubectl get deploy/my-dep-nginx -oyaml | grep image
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/fe9fae94d1e34214909a1e1a9a3da5aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f235149f45364f58ab8dfb1c24af42f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 6、其它工作负载

> [https://kubernetes.io/zh/docs/concepts/workloads/controllers](https://kubernetes.io/zh/docs/concepts/workloads/controllers)

1. `Deployment`: 无状态应用部署 ex: 微服务
2. `StatefulSet`: 有状态应用 ex: redis
3. `DaemonSet`: 守护型应用部署 ex: 日志收集组件
4. `Job`: 定时任务部署 ex: 垃圾清理组件
5. ...

### 六、Service

> 将一组Pods公开为网络服务的抽象方法；Pod的服务发现与负载均衡。

![在这里插入图片描述](https://img-blog.csdnimg.cn/90538b405a3d4529b3a221f4b9e6b92b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

###### 命令行

```shell
# 暴露Deploy  => 将目标服务端口80暴露为8000
kubectl expose deploy my-dep-nginx --port=8000 --target-port=80

# 查看已暴露的服务
kubectl get service

# 访问 -- ip方式
curl 10.96.23.211:8000

# 访问 -- service域名方式
# 进入容器 curl 服务名.命名空间.svc:8000
curl my-dep-nginx.default.svc:8000

# 删除已暴露的服务
kubectl delete service my-dep-nginx

# 使用标签检索Pod
kubectl get pod -l app=my-dep-nginx
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/c42170df7eac4bc885a2562326d13a8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f47129c9b26247d99d288cb8b11960ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

###### 配置文件

```shell
cat <<EOF | sudo tee ./my-dep-nginx-service.yaml

apiVersion: v1
kind: Service
metadata:
  labels:
    app: my-dep-nginx
  name: my-dep-nginx
spec:
  selector:
    app: my-dep-nginx
  ports:
  - port: 8000
    protocol: TCP
    targetPort: 80
    
EOF

# 创建
kubectl apply -f my-dep-nginx-service.yaml
# 删除
kubectl delete -f my-dep-nginx-service.yaml
```

#### 1、ClusterIP

> 用于集群内部访问

##### a、命令行

```shell
# 等同于没有`--type`，即上面方式
kubectl expose deploy my-dep-nginx --port=8000 --target-port=80 --type=ClusterIP
# 删除
kubectl delete service my-dep-nginx
```

##### b、配置文件

```shell
cat <<EOF | sudo tee ./my-dep-nginx-service-clusterip.yaml

apiVersion: v1
kind: Service
metadata:
  labels:
    app: my-dep-nginx
  name: my-dep-nginx
spec:
  ports:
  - port: 8000
    protocol: TCP
    targetPort: 80
  selector:
    app: my-dep-nginx
  type: ClusterIP
  
EOF

# 创建
kubectl apply -f my-dep-nginx-service-clusterip.yaml
# 删除
kubectl delete -f my-dep-nginx-service-clusterip.yaml
```

#### 2、NodePort

> 用于集群外部访问，NodePort范围在 30000-32767 之间

##### a、命令行

```shell
kubectl expose deploy my-dep-nginx --port=8000 --target-port=80 --type=NodePort
# 删除
kubectl delete service my-dep-nginx
```

访问：`http://集群任意IP:端口`

##### b、配置文件

```shell
cat <<EOF | sudo tee ./my-dep-nginx-service-nodeport.yaml

apiVersion: v1
kind: Service
metadata:
  labels:
    app: my-dep-nginx
  name: my-dep-nginx
spec:
  ports:
  - port: 8000
    protocol: TCP
    targetPort: 80
  selector:
    app: my-dep-nginx
  type: NodePort

EOF

# 创建
kubectl apply -f my-dep-nginx-service-nodeport.yaml
# 删除
kubectl delete -f my-dep-nginx-service-nodeport.yaml
```

### 七、Ingress

> Service的统一网关入口
> [https://kubernetes.io/zh/docs/concepts/services-networking/ingress](https://kubernetes.io/zh/docs/concepts/services-networking/ingress)
> [https://github.com/kubernetes/ingress-nginx](https://github.com/kubernetes/ingress-nginx)

![在这里插入图片描述](https://img-blog.csdnimg.cn/b1788b4e001c420685227e8085691977.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 1、安装

```shell
wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml

# 修改镜像 
# image: k8s.gcr.io/ingress-nginx/controller:v0.46.0@sha256:52f0058bed0a17ab0fb35628ba97e8d52b5d32299fbc03cc0f6c7b9ff036b61a
# 变更为
# image: registry.cn-hangzhou.aliyuncs.com/zhengqing/ingress-nginx-controller:v0.46.0
vim deploy.yaml

# 创建
kubectl apply -f deploy.yaml

# 查看安装是否安装完成
kubectl get pod -A

# 检查安装的结果
kubectl get pod,svc -n ingress-nginx

# 安装完成之后，查看Service暴露端口
kubectl get svc -A
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/e7d11b0e7e944c0cb78dbfc88bb90f17.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

访问

1. `https://集群任意IP:32248`
2. `http://集群任意IP:31424`

![在这里插入图片描述](https://img-blog.csdnimg.cn/c7f8e6f4026548c080277111ff52a815.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 2、使用

准备测试环境

```shell
cat <<EOF | sudo tee ./ingress-test.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: service1
spec:
  replicas: 2
  selector:
    matchLabels:
      app: service1
  template:
    metadata:
      labels:
        app: service1
    spec:
      containers:
      - name: service1
        image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server
        ports:
        - containerPort: 9000
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: service2
  name: service2
spec:
  replicas: 2
  selector:
    matchLabels:
      app: service2
  template:
    metadata:
      labels:
        app: service2
    spec:
      containers:
      - image: nginx
        name: nginx
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: service2
  name: service2
spec:
  selector:
    app: service2
  ports:
  - port: 8000
    protocol: TCP
    targetPort: 80
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: service1
  name: service1
spec:
  selector:
    app: service1
  ports:
  - port: 8000
    protocol: TCP
    targetPort: 9000
    
EOF


# 创建
kubectl apply -f ingress-test.yaml
# 删除
# kubectl delete -f ingress-test.yaml
```

##### a、域名访问

![在这里插入图片描述](https://img-blog.csdnimg.cn/d5c0b7c957ff49b78620a163b3ae4068.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

```shell
cat <<EOF | sudo tee ./ingress-rule-host.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress  
metadata:
  name: ingress-host-bar
spec:
  ingressClassName: nginx
  rules:
  - host: "foo.bar.com"
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service1
            port:
              number: 80
  - host: "bar.foo.com"
    http:
      paths:
      - pathType: Prefix
        path: "/nginx"      # 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404
        backend:
          service:
            name: service2  # java，比如使用路径重写，去掉前缀nginx
            port:
              number: 80

EOF


# 创建
kubectl apply -f ingress-rule-host.yaml
# 删除
# kubectl delete -f ingress-rule-host.yaml

# 查看规则
kubectl get ingress
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/e70ec9120e47402d94a5b87bc2e6a6fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

访问

> hosts域名切换工具 [https://github.com/oldj/SwitchHosts](https://github.com/oldj/SwitchHosts)

![在这里插入图片描述](https://img-blog.csdnimg.cn/33f357fb5a31426db14d6ab7458e74e7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

1. `foo.bar.com:31424`       => service1
2. `bar.foo.com:31424`       => service2 -- ingress层返回404
2. `bar.foo.com:31424/nginx` => service2 -- nginx层返回404

![在这里插入图片描述](https://img-blog.csdnimg.cn/25eea96caf7a4b85bac3dcc19dc5f36a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### b、路径重写

> [https://kubernetes.github.io/ingress-nginx/examples/rewrite](https://kubernetes.github.io/ingress-nginx/examples/rewrite)

```shell
cat <<EOF | sudo tee ./ingress-rule-rewrite.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress  
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
  name: ingress-host-bar
spec:
  ingressClassName: nginx
  rules:
  - host: "foo.bar.com"
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service1
            port:
              number: 80
  - host: "bar.foo.com"
    http:
      paths:
      - pathType: Prefix
        path: "/nginx(/|$)(.*)"  # 把请求会转给下面的服务，下面的服务一定要能处理这个路径，不能处理就是404
        backend:
          service:
            name: service2       # java，比如使用路径重写，去掉前缀nginx
            port:
              number: 80

EOF


# 创建
kubectl apply -f ingress-rule-rewrite.yaml
# 删除
# kubectl delete -f ingress-rule-rewrite.yaml

# 查看规则
kubectl get ingress
```

访问 `bar.foo.com:31424/nginx` => `bar.foo.com:31424` 即访问nginx根路径
![在这里插入图片描述](https://img-blog.csdnimg.cn/979006ee078347849b15f90f17c2f6c2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### c、流量限制

> [https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting](https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting)

```shell
cat <<EOF | sudo tee ./ingress-rule-limit.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-limit-rate
  annotations:
    nginx.ingress.kubernetes.io/limit-rps: "1"
spec:
  ingressClassName: nginx
  rules:
  - host: "limit.ingress.com"
    http:
      paths:
      - pathType: Exact
        path: "/"
        backend:
          service:
            name: service2
            port:
              number: 80
              
EOF


# 创建
kubectl apply -f ingress-rule-limit.yaml
# 删除
# kubectl delete -f ingress-rule-limit.yaml

# 查看规则
kubectl get ingress
```

频繁访问 `limit.ingress.com:31424` 会出现503
![在这里插入图片描述](https://img-blog.csdnimg.cn/a54b2d34a1da442da82b3aec3245530d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

### 八、存储抽象

> 以`NFS`作为存储层为例
> 节点之间互相同步数据

#### 1、环境准备

##### a、所有节点

```shell
# 所有机器安装
yum install -y nfs-utils
```

##### b、主节点

```shell
# nfs主节点
echo "/nfs/data/ *(insecure,rw,sync,no_root_squash)" > /etc/exports
mkdir -p /nfs/data

# 设置开机自启 & 现在启动  -- 远程绑定服务
systemctl enable rpcbind --now

# nfs服务
systemctl enable nfs-server --now

# 配置生效
exportfs -r

# 查看
exportfs
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c3a534405374a1ab5b8185537875d4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### c、从节点

```shell
# 查看远程机器有哪些目录可以同步 -- 使用master机器ip地址
showmount -e 192.168.101.20

# 执行以下命令挂载 nfs 服务器上的共享目录到本机路径
mkdir -p /nfs/data

# 同步远程机器数据
mount -t nfs 192.168.101.20:/nfs/data /nfs/data
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/5480f56fc74a41fabe02b37e2e8339ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

测试

```shell
# 在任意机器写入一个测试文件
echo "hello nfs server" > /nfs/data/test.txt

# 在其它机器查看数据
cat /nfs/data/test.txt
```

##### d、原生方式数据挂载

> master机器执行

```shell
# 先创建共享目录
mkdir -p /nfs/data/nginx-pv

cat <<EOF | sudo tee ./nginx-nfs.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: nginx-pv-demo
  name: nginx-pv-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-pv-demo
  template:
    metadata:
      labels:
        app: nginx-pv-demo
    spec:
      containers:
      - image: nginx
        name: nginx
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
        - name: html
          nfs:
            server: 192.168.101.20 # 使用master机器ip地址
            path: /nfs/data/nginx-pv
            
EOF


# 创建
kubectl apply -f nginx-nfs.yaml
# 删除
# kubectl delete -f nginx-nfs.yaml

# 写入数据，然后访问测试
echo "hello nfs" > /nfs/data/nginx-pv/index.html
```

> tips: 如果删除服务，挂载的数据是不会删除的！

```shell
# 删除
kubectl delete -f nginx-nfs.yaml

# 查看挂载数据
cat /nfs/data/nginx-pv/index.html
```

#### 2、 PV&PVC -- 挂载目录

1. `PV`：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置 ex: /nfs/data/nginx-pv
2. `PVC`：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格 ex: 申请10MB

> ex: `pv01`给10MB `pv02`给1GB `pv03`给3GB；
> 1. 静态供应: 提前申请创建，而非要多大就动态创建多大。
> 2. 当一个pvc来申请10MB的时候，会给一个`pv01`的合适空间，而不是给`pv02`。
> 3. 如果删除pod和其下pvc时，关联`pv01`空间也会被回收。
> 4. 如果之后内容增长超过`pv0x`规定的空间大小将会报错。

##### a、创建pv池

> master机器执行

```shell
# nfs主节点创建3个文件夹
mkdir -p /nfs/data/01
mkdir -p /nfs/data/02
mkdir -p /nfs/data/03
```

创建PV

```shell
cat <<EOF | sudo tee ./pv.yaml

apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv01-10m   # 注：小写
spec:
  capacity:
    storage: 10M  # 给10M空间
  accessModes:
    - ReadWriteMany   # 多节点可读可写
  storageClassName: nfs
  nfs:
    path: /nfs/data/01
    server: 192.168.101.20 # 使用master机器ip地址
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv02-1gi
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteMany
  storageClassName: nfs
  nfs:
    path: /nfs/data/02
    server: 192.168.101.20
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv03-3gi
spec:
  capacity:
    storage: 3Gi
  accessModes:
    - ReadWriteMany
  storageClassName: nfs
  nfs:
    path: /nfs/data/03
    server: 192.168.101.20

EOF


# 创建
kubectl apply -f pv.yaml
# 删除
# kubectl delete -f pv.yaml

# 查看系统资源
kubectl get persistentvolume
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d8d88d23511d43b9be77a8cd1b99c7b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### b、PVC创建与绑定

> master机器执行

创建PVC

```shell
cat <<EOF | sudo tee ./pvc.yaml

kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: nginx-pvc
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 200Mi
  storageClassName: nfs

EOF


# 应用
kubectl apply -f pvc.yaml

# 查看pv -- `CLAIM`会选择一个合适的空间`pv02`进行绑定 `default/nginx-pvc`
kubectl get pv

# 删除再查看 会发现`STATUS`值为`Released` 即空间被释放
kubectl delete -f pvc.yaml && kubectl get pv

# 再次应用会重新绑定 由于之前的`pv02`未释放，将会绑定`pv03`
kubectl apply -f pvc.yaml && kubectl get pv
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/eea12be1ec1941d3a44b9c0de426121b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

创建Pod绑定PVC

```shell
cat <<EOF | sudo tee ./pod-pvc.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: nginx-deploy-pvc
  name: nginx-deploy-pvc
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-deploy-pvc
  template:
    metadata:
      labels:
        app: nginx-deploy-pvc
    spec:
      containers:
      - image: nginx
        name: nginx
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
        - name: html
          persistentVolumeClaim:
            claimName: nginx-pvc

EOF


# 创建
kubectl apply -f pod-pvc.yaml
# 删除
# kubectl delete -f pod-pvc.yaml

# 查看pod正常启动
kubectl get pod

# 查看pvc,pv  --  `nginx-pvc`绑定挂载卷`pv03-3gi`
kubectl get pvc,pv

# 修改`pv03`查看内容是否变更
echo "hello 03" > /nfs/data/03/index.html
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/12074fd1f6a5474587f95cb636d1f28a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/b2077db3e146481a97933f6dc6aaab44.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 3、ConfigMap -- 挂载配置文件

> 抽取应用配置，并且可以自动更新。
> redis示例

##### 1、将配置文件创建为配置集

```shell
# 创建redis配置文件
cat <<EOF | sudo tee ./redis.conf
appendonly yes
EOF

# 创建配置集，redis保存到k8s的etcd
kubectl create cm redis-conf --from-file=redis.conf

# 删除配置，创建好配置集，就不需要了...
rm -rf redis.conf

# 查看
kubectl get cm
kubectl get cm redis-conf -oyaml
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/181f665a73a64a00b30627ccc8724c7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

```yml
apiVersion: v1
data: # data是所有真正的数据
  redis.conf: |       # key：默认是文件名
    appendonly yes    # value：配置文件的内容
kind: ConfigMap
metadata:
  name: redis-conf
  namespace: default
```

##### 2、创建Pod

```shell
cat <<EOF | sudo tee ./pod-redis.yaml

apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis
    command:
      - redis-server
      - "/redis-master/redis.conf"   # 指redis容器内部的位置
    ports:
    - containerPort: 6379
    volumeMounts:
    - mountPath: /data
      name: data
    - mountPath: /redis-master
      name: config
  volumes:
    - name: data
      emptyDir: {}
    - name: config
      configMap:
        name: redis-conf   # 对应上一步创建的`redis-conf`配置集
        items:
        - key: redis.conf
          path: redis.conf
            
EOF


# 创建
kubectl apply -f pod-redis.yaml
# 删除
# kubectl delete -f pod-redis.yaml
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/6f22fb7e856341959ffcae6743b038aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 3、查看

```shell
kubectl exec -it redis -- /bin/bash
cat /redis-master/redis.conf
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/791dda86cfeb423ebad2c95017fbc600.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 4、修改ConfigMap

```shell
kubectl edit cm redis-conf
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/3057c7a92218491ab58eccbc302e8ade.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 5、检查配置是否更新

等一会儿查看配置，发现会自动将配置同步过来

```shell
kubectl exec -it redis -- /bin/bash
cat /redis-master/redis.conf

# 此配置需要redis重启之后才会生效 -- 原因：redis中间件自身无此配置热更新功能
redis-cli
127.0.0.1:6379> CONFIG GET appendonly
127.0.0.1:6379> CONFIG GET requirepass 
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/22b382bdb00d428aa87fcc87ad523477.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)
![在这里插入图片描述](https://img-blog.csdnimg.cn/ee2d4421ab6b498aa504638ee647fe79.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 4、Secret -- 保存密码等敏感数据

> Secret 对象类型用来保存敏感信息，ex：密码、OAuth令牌、SSH密钥。

```shell
# 命令格式
kubectl create secret docker-registry docker-secret-zhengqingya \
    --docker-server=镜像仓库服务器 \
    --docker-username=用户名 \
    --docker-password=密码 \
    --docker-email=邮箱地址

# ex:
kubectl create secret docker-registry docker-secret-zhengqingya \
    --docker-server=registry.cn-hangzhou.aliyuncs.com \
    --docker-username=zhengqingya \
    --docker-password=xxx \
    --docker-email=xxx@qq.com
  
# 查看
kubectl get secret
kubectl get secret docker-secret-zhengqingya -oyaml

# 对密码进行base64解密查看
echo 'emhxxxnLg==' | base64 --decode
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/0acd3adeff4e47f6bf200fa373e8b9f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6YOR5riF,size_20,color_FFFFFF,t_70,g_se,x_16)

测试

```shell
cat <<EOF | sudo tee ./docker-secret-test.yaml

apiVersion: v1
kind: Pod
metadata:
  name: private-nginx
spec:
  containers:
  - name: private-nginx
    image: registry.cn-hangzhou.aliyuncs.com/zhengqing/nginx
  imagePullSecrets:
  - name: docker-secret-zhengqingya   # 使用自己的密钥信息
            
EOF


# 创建
kubectl apply -f docker-secret-test.yaml
# 删除
kubectl delete -f docker-secret-test.yaml
```

---

> 今日分享语句：
> 生活可以是甜的，也可以是苦的，但不能是没味的。你可以胜利，也可以失败，但你不能屈服。
